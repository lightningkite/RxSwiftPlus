// Generated by Khrysalis Swift converter - this file will be overwritten.
// File: Image.kt
// Package: com.lightningkite.butterfly
import Foundation
import RxSwift
import UIKit

public protocol Image { func load() -> Single<UIImage> }
public struct ImageLocalUrl: Image, Hashable {
    public var url: URL
    public init(_ url: URL) { self.url = url }
    public func load() -> Single<UIImage> {
        if let image = UIImage(fileURLWithPath: url) {
            return Single.just(image)
        } else {
            return Single.error(HttpError.invalidUrl)
        }
    }
}
public struct ImageUI: Image, Hashable {
    public var uiImage: UIImage
    public init(_ uiImage: UIImage) { self.uiImage = uiImage }
    public func load() -> Single<UIImage> { Single.just(uiImage) }
}
public struct ImageRaw: Image, Hashable {
    public var raw: Data
    public init(_ raw: Data) { self.raw = raw }
    public func load() -> Single<UIImage> { UIImage(data: raw).map { Single.just($0) } ?? Single.error(ImageLoadError.notImage) }
}
public struct ImageRemoteUrl: Image, Hashable {
    public var url: URL
    public init(_ url: URL) { self.url = url }
    public func load() -> Single<UIImage> { loadImage(uri: url) }
}
public struct ImageLayer: Image, Hashable {
    public static func == (lhs: ImageLayer, rhs: ImageLayer) -> Bool {
        return lhs.identifier == rhs.identifier
    }
    public func hash(into hasher: inout Hasher) {
        hasher.combine(identifier)
    }
    public var identifier = arc4random()
    public var maker: () -> CALayer
    public init(_ maker: @escaping () -> CALayer) { self.maker = maker }
    public init(_ color: UIColor) { self.maker = {
        let newLayer = CALayer()
        newLayer.backgroundColor = color.cgColor
        return newLayer
    } }
    public func load() -> Single<UIImage> { maker().toImage().map { Single.just($0) } ?? Single.error(ImageLoadError.notImage) }
}

public enum ImageLoadError: Error {
    case requestError
    case notImage
}

private extension CALayer {
    func toImage() -> UIImage? {
        if CFGetTypeID(self.contents as CFTypeRef) == CGImage.typeID {
            return UIImage(cgImage: self.contents as! CGImage)
        } else {
            UIGraphicsBeginImageContextWithOptions(self.bounds.size, self.isOpaque, 0.0)
            guard let ctx = UIGraphicsGetCurrentContext() else {
                print("WARNING!  NO CURRENT CONTEXT!")
                UIGraphicsEndImageContext()
                return nil
            }
            self.render(in: ctx)
            let img = UIGraphicsGetImageFromCurrentImageContext()
            UIGraphicsEndImageContext()
            setNeedsDisplay()
            return img
        }
    }
}

private func loadImage(uri: URL, maxDimension: Int32 = 2048) -> Single<UIImage> {
    return Single.create { em in
        URLSession.shared.dataTask(with: uri, completionHandler: { data, response, error in
            DispatchQueue.main.async {
                if let data = data {
                    if let img = UIImage(data: data) {
                        em.on(.success(img))
                    } else {
                        em.on(.failure(ImageLoadError.notImage))
                    }
                } else if let error = error {
                    em.on(.failure(error))
                } else {
                    em.on(.failure(ImageLoadError.requestError))
                }
            }
        }).resume()
    }
}

public extension UIImageView {
    func setImage(_ image: Image?) {
        self.image = nil
        if let image = image {
            switch image {
            case let image as ImageLocalUrl:
                setImageFromLocalUrl(url: image.url)
            case let image as ImageUI:
                self.image = image.uiImage
            case let image as ImageRemoteUrl:
                setImageFromRemoteUrl(url: image.url)
            default:
                let activityIndicatorView = UIActivityIndicatorView(style: .gray)
                activityIndicatorView.startAnimating()
                activityIndicatorView.center.x = self.frame.size.width / 2
                activityIndicatorView.center.y = self.frame.size.height / 2
                self.addSubview(activityIndicatorView)
                weak var weakAIV = activityIndicatorView
                image.load()
                    .do(onSuccess: { self.image = $0 }, onSubscribe: {  }, onDispose: { weakAIV?.removeFromSuperview() })
                    .subscribe()
                    .disposed(by: self.removed)
            }
        }
    }
    
    private func setImageFromLocalUrl(url: URL) {
        self.image = UIImage(fileURLWithPath: url)
    }
    
    private func setImageFromRemoteUrl(url: URL) {
        let activityIndicatorView = UIActivityIndicatorView(style: .gray)
        activityIndicatorView.startAnimating()
        activityIndicatorView.center.x = self.frame.size.width / 2
        activityIndicatorView.center.y = self.frame.size.height / 2
        self.addSubview(activityIndicatorView)
        weak var weakAIV = activityIndicatorView
        URLSession.shared.dataTask(with: URLRequest(url: url, cachePolicy: .returnCacheDataElseLoad, timeoutInterval: 30)){ [weak self] data, response, error in
            guard
                let httpURLResponse = response as? HTTPURLResponse, httpURLResponse.statusCode == 200,
                let mimeType = response?.mimeType, mimeType.hasPrefix("image"),
                let data = data, error == nil,
                let image = UIImage(data: data)
                else {
                    DispatchQueue.main.async() {
                        weakAIV?.removeFromSuperview()
                    }
                return
                }
            DispatchQueue.main.async() { [weak self] in
                weakAIV?.removeFromSuperview()
                self?.image = image
            }
        }.resume()
    }
}
