// Generated by Khrysalis Swift converter - this file will be overwritten.
// File: Image.kt
// Package: com.lightningkite.butterfly
import Foundation
import RxSwift
import UIKit

public enum Image {
    case localUrl(_ url: URL)
    case ui(_ uiImage: UIImage)
    case raw(_ raw: Data)
    case remoteUrl(_ url: URL)
    case layer(_ maker: ()->CALayer)
    
    func load() -> Single<UIImage> {
        switch self {
        case .localUrl(url: let url):
            return loadImage(uri: url)
        case .ui(uiImage: let uiImage):
            return Single.just(uiImage)
        case .raw(raw: let raw):
            return UIImage(data: raw).map { Single.just($0) } ?? Single.error(ImageLoadError.notImage)
        case .remoteUrl(url: let url):
            return loadImage(uri: url)
        case .layer(maker: let maker):
            return maker().toImage().map { Single.just($0) } ?? Single.error(ImageLoadError.notImage)
        }
    }
}

public enum ImageLoadError: Error {
    case requestError
    case notImage
}

private extension CALayer {
    func toImage() -> UIImage? {
        if CFGetTypeID(self.contents as CFTypeRef) == CGImage.typeID {
            return UIImage(cgImage: self.contents as! CGImage)
        } else {
            setNeedsDisplay()
            UIGraphicsBeginImageContextWithOptions(self.bounds.size, self.isOpaque, 0.0)
            guard let ctx = UIGraphicsGetCurrentContext() else {
                print("WARNING!  NO CURRENT CONTEXT!")
                return nil
            }
            self.render(in: ctx)
            let img = UIGraphicsGetImageFromCurrentImageContext()
            UIGraphicsEndImageContext()
            return img
        }
    }
}

private func loadImage(uri: URL, maxDimension: Int32 = 2048) -> Single<UIImage> {
    return Single.create { em in
        URLSession.shared.dataTask(with: uri, completionHandler: { data, response, error in
            DispatchQueue.main.async {
                if let data = data {
                    if let img = UIImage(data: data) {
                        em.on(.success(img))
                    } else {
                        em.on(.failure(ImageLoadError.notImage))
                    }
                } else if let error = error {
                    em.on(.failure(error))
                } else {
                    em.on(.failure(ImageLoadError.requestError))
                }
            }
        }).resume()
    }
}

public extension UIImageView {
    func setImage(_ image: Image) {
        self.image = nil
        switch image {
        case .localUrl(url: let url):
            setImageFromUrl(url: url)
        case .ui(uiImage: let uiImage):
            self.image = uiImage
        case .remoteUrl(url: let url):
            setImageFromUrl(url: url)
        default:
            let activityIndicatorView = UIActivityIndicatorView(style: .gray)
            activityIndicatorView.startAnimating()
            activityIndicatorView.center.x = self.frame.size.width / 2
            activityIndicatorView.center.y = self.frame.size.height / 2
            self.addSubview(activityIndicatorView)
            weak var weakAIV = activityIndicatorView
            image.load()
                .do(onSuccess: { self.image = $0 }, onSubscribe: {  }, onDispose: { weakAIV?.removeFromSuperview() })
                .subscribe()
                .disposed(by: self.removed)
        }
    }
    
    private func setImageFromUrl(url: URL) {
        let activityIndicatorView = UIActivityIndicatorView(style: .gray)
        activityIndicatorView.startAnimating()
        activityIndicatorView.center.x = self.frame.size.width / 2
        activityIndicatorView.center.y = self.frame.size.height / 2
        self.addSubview(activityIndicatorView)
        weak var weakAIV = activityIndicatorView
        URLSession.shared.dataTask(with: URLRequest(url: url, cachePolicy: .useProtocolCachePolicy, timeoutInterval: 30)){ [weak self] data, response, error in
            guard
                let httpURLResponse = response as? HTTPURLResponse, httpURLResponse.statusCode == 200,
                let mimeType = response?.mimeType, mimeType.hasPrefix("image"),
                let data = data, error == nil,
                let image = UIImage(data: data)
                else {
                    DispatchQueue.main.async() {
                        weakAIV?.removeFromSuperview()
                    }
                return
                }
            DispatchQueue.main.async() { [weak self] in
                weakAIV?.removeFromSuperview()
                self?.image = image
            }
        }.resume()
    }
}
